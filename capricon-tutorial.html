<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marc Coiffier" />
  <title>First steps with CaPriCon</title>
  <style type="text/css">
    code{white-space: pre;}
    #capricon-prelude { display: none; }
    .capricon-output { display: inline-block; }
    .capricon-hide + .capricon-hidestache::before {
	content: "";
	width: 0.5em; height: 0.5em; display: inline-block;
	position: relative; bottom: 0.3em;
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAgCAQAAABNlRuNAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfiCR0AADLw7KyaAAAB3UlEQVQ4y43UPUhVYRzH8c99scTMLAkkySx0MNOipfeW2iqa2xrEGgIpjQY3l4YwIxJ6gbaWpIZAC1oaggoiJKgsjODSGxJBwaUyb09Dp8O9ei6c3/Q8P/j+n//bORnptUm/4Gw+NdDpsl1KPqYF6twQBMHtbEpkr0PRqZivEnOfRhO+RveMw5aDec+SgHojiuYNxk7egBl/BG/1JCH95v5lbUmZ2+6UR4blFgPtpv8XGiNtOmXRpCHpjRMREJyLnJwxBVfsVqVZQ74LgqKDkdMavTuuNhmpt981H0xqjJz1ZgQlfdVG1oisHp2xl3PMQ6OakpFeD5y0YYGb0aCmWlL3BMFdq1RVZQ/qrAHvfJNSeUM+eWxr7DRoSRpeuWp1aYlv20166UjaF+kyFVVWlw5Y6nq0BU+sTC6/RlNF1lvi6X/xMwlpdcF9x8tC7LA6Oj31Y3ESTW4Jgueayyo5741g1rakvAeUBEFBR4XfbtBAxVcTqSXqTPAiGiUb9euWJXnhD/gVITfjiMOCgtG4ngXlTxszI5h3xxxYZifW2iNTfQodTrsYr3eNq4LfZT+MCjU7qluGivVe54w+K5KRXkUFl7RJrXFB8NnmtEDWeyVMeJUWyXmtZMqI2bTIX4FHiXN3BEaSAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE4LTA5LTI4VDIzOjM0OjE0KzAyOjAw5BdphAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOC0wOS0yOFQyMjowMDo1MCswMjowMKjQ5C8AAAAASUVORK5CYII=);
	background-size: 100% 100%;
	background-repeat: none;
	padding: 0.2em;
	border: 1px solid rgba(255,255,255,0);
    }
  </style>
  <noscript>
    <style>.interactive { display: none !important; }</style>
  </noscript>
  <link rel="stylesheet" href="style.css" />
  <script src="mathjax/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- <script src="WiQEE.js"></script> -->
  <script defer src="WiQEE.js"></script>
  <script src="theme-tweak.js"></script>
</head>
<body class="ground-light primary" style="font-size: 100%;">
<main id="content-frame" class="frame"><header class="nav header reverse">
    <span class="menu left"><a href="index.html">WiQEE</a><ul>
  	<li><a href="#">Documentation</a><ul>
	    <li><a href="lexicon.html">Lexicon</a></li>
  	    <li><a href="capricon-tutorial.html">Tutorial</a></li>
	</ul></li>
	<li><a class="interactive" href="#" onclick="document.getElementById('body-theme-chooser').classList.toggle('active'); document.body.classList.toggle('smooth-colors');">Tweak theme</a></li>
    </ul></span><span class="menu middle"><a class="#">First steps with CaPriCon</a>
            <ul>
      <li><a href="#stacks-and-the-stack">Stacks, and The Stack</a></li>
      <li><a href="#your-first-words">Your First Words</a><ul>
      <li><a href="#nouns">Nouns</a></li>
      <li><a href="#verbs-and-vocabularies">Verbs and Vocabularies</a></li>
      <li><a href="#quotes">Quotes</a></li>
      </ul></li>
      <li><a href="#proof-assembly">Proof assembly</a><ul>
      <li><a href="#types-and-universes">Types and Universes</a></li>
      <li><a href="#the-proof-context">The proof context</a><ul>
      <li><a href="#introducing-new-hypotheses">Introducing new hypotheses</a></li>
      <li><a href="#using-hypotheses">Using hypotheses</a></li>
      <li><a href="#clearing-hypotheses">Clearing hypotheses</a></li>
      </ul></li>
      <li><a href="#functions-products-and-applications">Functions, Products and Applications</a></li>
      </ul></li>
      </ul>
          </span><span class="menu right"><a href="capricon-tutorial.md">Page source</a><ul>
	<li><a href="https://github.com/lih/WiQEE-pages/edit/master/capricon-tutorial.md">Edit</a></li>
	<li><a href="capricon-tutorial.pdf">PDF version</a></li>
      </ul></span>
  </header><div id="content-scroll"><article id="content" class="sheet" tabindex="1">
<h1>First steps with CaPriCon</h1>
<p>This page is intended as a tutorial on the use of a stack-based proof environment like the one provided on this site. Since we’re going to need to print things out, and we don’t yet have the knowledge to write such features ourselves, let’s first import a few useful functions from a preexisting module.</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 2.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="'utils">'utils</span> <span class="symbol" data-symbol-name="require">require</span> <span class="symbol" data-symbol-name="import">import</span></pre>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">
<ul>
<li>Required module: <a href="utils.html">utils</a></li>
</ul>
</div>
<p>Among other things, this module defines one function that will be of interest to us : <code>vis</code>. When called, this function simply prints out every hypothesis in context and every value currently on the stack. It’s very useful as the final word in a sentence, to show the resulting context. It doesn’t change anything, so feel free to sprinkle it at any point of your scripts for debugging purposes.</p>
<p>Now, in order to understand what a stack-based language is, we first have to understand the basic concept of a <em>stack</em>, and the role it plays during the execution of a script.</p>
<h2 id="stacks-and-the-stack">Stacks, and The Stack</h2>
<p>A stack, in general, is a list of values, to which we arbitrarily assign two extremes, a <em>top</em> and a <em>bottom</em>. We can operate on either side, but as a general simplifying convention, all stack operations will take place at the top unless specified otherwise.</p>
<p>The most fundamental operations that can be carried out on a stack are <em>pushing</em> and <em>popping</em> values to and from it (at the top).</p>
<p><br/></p>
<p>What does that have to do with CaPriCon ? Well, stack-based languages, as their name implies, implicitly operate on a stack, that serves as temporary storage for all the intermediate results of a computation. When we talk about <em>the stack</em>, without any more context, you can assume we’re talking about this one.</p>
<p>In most stack-based languages, including CaPriCon, words designate <em>instructions</em> that modify the stack according to predefined rules, and complex scripts can be written by stringing words together in the right order, changing the stack in ever more interesting ways.</p>
<hr/>
<h2 id="your-first-words">Your First Words</h2>
<p>Let’s start talking a little. As mentioned above, a sentence (or program) is comprised of several words separated by whitespace. Words can fall into one of three categories :</p>
<ul>
<li><em>nouns</em> are constant words, that push a value onto the stack when run</li>
<li><em>verbs</em> are operational words, that can modify the stack or the environment when they are run</li>
<li><em>quotes</em> are sequences of <em>steps</em>, where a step can be either a word step, or a splice step (quotes and steps will be described in more detail below).</li>
</ul>
<h3 id="nouns">Nouns</h3>
<p>The simplest kinds of words are <em>nouns</em>, more commonly known as atoms or symbols, and are written as a single quote (<code>'</code>), followed by some non-space characters.</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="'Bender">'Bender</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
<button class="capricon-example" data-code="&#39;is &#39;great vis">
<pre class="capricon"><span class="symbol" data-symbol-name="'is">'is</span> <span class="symbol" data-symbol-name="'great">'great</span> <span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>As you can see, each noun you write is pushed onto the stack, in the order in which they appear. Nothing mysterious here.</p>
<p>The CaPriCon interpreter also recognizes numbers<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, in the usual decimal format, as another kind of noun, which means they will mostly behave as expected.</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="1">1</span> <span class="symbol" data-symbol-name="2">2</span> <span class="symbol" data-symbol-name="100">100</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>You now know what happens when you write <code>'vis</code>, but how does <code>vis</code> alone get interpreted ?</p>
<h3 id="verbs-and-vocabularies">Verbs and Vocabularies</h3>
<p>In parallel to the stack, the interpreter also features its own <em>vocabulary</em>, which provides a correspondance between all the known nouns and their definitions.</p>
<p>Whenever a verb is run, the interpreter looks into its vocabulary for the meaning of that verb and executes it, with a different strategy depending on that meaning :</p>
<ul>
<li>if it is a quote, then the interpreter runs each step in the quote</li>
<li>if it is a special builtin operation, then that operation is run according to its definition. The initial vocabulary provides a few builtins operations of that sort, which are listed <a href="lexicon.html">here</a>.</li>
<li>otherwise, it is simply pushed onto the stack, as a constant</li>
</ul>
<p>There are two main verbs to interact with the vocabulary : <code>def</code>, for adding new definitions, and overriding old ones; and <code>$</code>, for looking symbols up. They can be used as follows :</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="'x">'x</span> <span class="symbol" data-symbol-name="3">3</span> <span class="symbol" data-symbol-name="def">def</span> <span class="symbol" data-symbol-name="'y">'y</span> <span class="symbol" data-symbol-name="4">4</span> <span class="symbol" data-symbol-name="def">def</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="y &#39;x $ &quot;\&quot;&#39;x $\&quot;=%v; y=%v\n&quot; printf">
<pre class="capricon"><span class="symbol" data-symbol-name="y">y</span> <span class="symbol" data-symbol-name="'x">'x</span> <span class="symbol" data-symbol-name="$">$</span> <span class="symbol" data-symbol-name="&quot;\&quot;">&quot;\&quot;</span><span class="symbol" data-symbol-name="'x">'x</span> <span class="symbol" data-symbol-name="$\&quot;=%v;">$\&quot;=%v;</span> <span class="symbol" data-symbol-name="y=%v\n&quot;">y=%v\n&quot;</span> <span class="symbol" data-symbol-name="printf">printf</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>Of course, the most interesting verbs, and the ones I kept for last, are the ones referencing quotes, because they allow you to build upon simpler concepts to yield complex effects.</p>
<h3 id="quotes">Quotes</h3>
<p>Many stack-based language have features similar to our quotes. Let’s start there.</p>
<p>The <em>raison d’être</em> of a quote is, simply put, to be able to write a program and keep it in stasis, until it can be run from a verb (or from the stack, using the builtin verb <code>exec</code>). In CaPriCon, this can be achieved by enclosing the sentence you want to “freeze” in brackets, like so :</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 5.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="pop">pop</span> <span class="symbol" data-symbol-name="pop">pop</span> <span class="symbol" data-symbol-name="pop">pop</span> <span class="symbol" data-symbol-name="'is">'is</span> <span class="symbol" data-symbol-name="'great">'great</span>
<span class="quote quote-brace"><span class="symbol" data-symbol-name="{">{</span> <span class="symbol" data-symbol-name="swap">swap</span> <span class="symbol" data-symbol-name="2">2</span> <span class="symbol" data-symbol-name="shift">shift</span> <span class="symbol" data-symbol-name="&quot;%s %s %s !&quot;">&quot;%s %s %s !&quot;</span> <span class="symbol" data-symbol-name="format">format</span> <span class="symbol" data-symbol-name="}">}</span></span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
<button class="capricon-example" data-code="exec vis">
<pre class="capricon"><span class="symbol" data-symbol-name="exec">exec</span> <span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>That’s all fairly straightforward, which is nice, but quotes of this form aren’t very dynamic. They will always depend on, and possibly modify, their surrounding environment during evaluation (a feature commonly known as “dynamic binding”), which, while very flexible, doesn’t provide a reliable way to write composable programs.</p>
<p>This may not seem like a problem right away, and indeed it isn’t for the kinds of small examples we’ve been playing with, but for more reusable scripts, you should always be careful about the environment you leave behind when you’re done with your work. Also, it’s kind of a good feeling when you know your programs won’t accidentally rewrite an index and start an infinite loop.</p>
<h4 id="splices-and-quotes-a-case-study">Splices and quotes : a case study</h4>
<p>To better illustrate the need for a more powerful construct, let’s imagine we want to be able to execute a quote in a local environment, so that all nouns defined during that quote’s execution don’t accidentally override the outside vocabulary.</p>
<p>The idea is to use the <code>vocabulary</code> verb to retrieve the vocabulary before executing the quote, save that vocabulary somewhere, then run the quote (which can perform arbitrary modifications to the stack and the vocabulary), and finally restore the old vocabulary afterwards using <code>set-vocabulary</code>.</p>
<p>The question is : where do we save the old vocabulary, so that executing our argument won’t accidentally override the place we chose ? Given what we know about the stack and the environment, nowhere is safe. A value on the stack can always be <code>pop</code>ped or <code>clear</code>ed, and a definition in the vocabulary can always be overridden.</p>
<p>Answer : we save it in a quote. Without further ado, here is the solution that CaPriCon proposes :</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 6.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="clear">clear</span> <span class="symbol" data-symbol-name="'local-exec">'local-exec</span> <span class="quote quote-brace"><span class="symbol" data-symbol-name="{">{</span>
  <span class="quote quote-brace"><span class="symbol" data-symbol-name="{">{</span> <span class="symbol" data-symbol-name="exec">exec</span> <span class="quote quote-splice"><span class="symbol" data-symbol-name=",{">,{</span> <span class="symbol" data-symbol-name="vocabulary">vocabulary</span> <span class="symbol" data-symbol-name="}">}</span></span> <span class="symbol" data-symbol-name="set-vocabulary">set-vocabulary</span> <span class="symbol" data-symbol-name="}">}</span></span>
  <span class="symbol" data-symbol-name="exec">exec</span> <span class="symbol" data-symbol-name="}">}</span></span> <span class="symbol" data-symbol-name="def">def</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="{ &#39;x &quot;red&quot; def x &quot;x inside = %v\n&quot; printf } local-exec x &quot;x outside = %v\n&quot; printf">
<pre class="capricon"><span class="quote quote-brace"><span class="symbol" data-symbol-name="{">{</span> <span class="symbol" data-symbol-name="'x">'x</span> <span class="symbol" data-symbol-name="&quot;red&quot;">&quot;red&quot;</span> <span class="symbol" data-symbol-name="def">def</span> <span class="symbol" data-symbol-name="x">x</span> <span class="symbol" data-symbol-name="&quot;x inside = %v\n&quot;">&quot;x inside = %v\n&quot;</span> <span class="symbol" data-symbol-name="printf">printf</span> <span class="symbol" data-symbol-name="}">}</span></span> <span class="symbol" data-symbol-name="local-exec">local-exec</span> <span class="symbol" data-symbol-name="x">x</span> <span class="symbol" data-symbol-name="&quot;x outside = %v\n&quot;">&quot;x outside = %v\n&quot;</span> <span class="symbol" data-symbol-name="printf">printf</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>Let’s break this down : <code>local-exec</code> is defined as the quote that, first, creates a new quote by splicing a constant – derived from running <code>vocabulary</code> – between executing the top of the stack (our only argument of interest) and resetting the vocabulary to whatever the constant was at the time of creation.</p>
<p>Then, <code>local-exec</code> simply calls <code>exec</code> to run the newly-created quote that already remembers the <code>vocabulary</code> from before. Our argument gets executed, then the old vocabulary that was captured is pushed on the stack, only to be immediately restored to its rightful place by <code>set-vocabulary</code>. We now have the newly calculated stack, in an environment where our vocabulary is unchanged.</p>
<p><br/></p>
<p>This concludes the tour of all the basic CaPriCon language features. Once you’ve mastered those three concepts (nouns, verbs and quotes), and learned about enough builtin operations, all the programs, proofs and examples presented from this point on will be within your reach.</p>
<p>There’s just one last detail we haven’t gotten around to : building actual proofs. Until now, we’ve been playing around with names and definitions, but we haven’t yet proven anything of interest. That’s with good reason, because we don’t yet know how to build proofs.</p>
<p>Please bear with me for this last section, as I try to explain how to build mathematical proofs out of stacks, quotes and a bit of magic.</p>
<hr/>
<h1 id="proof-assembly">Proof assembly</h1>
<p>The easiest way to get comfortable manipulating mathematical proofs and theorems is to treat them like regular objects. In CaPriCon, theorems and proofs – which will hereafter be referred to as <em>terms</em> – are like numbers and symbols, that can be pushed onto the stack, or saved in the vocabulary.</p>
<h2 id="types-and-universes">Types and Universes</h2>
<p>The most common kind of basic term you’ll encounter are universes, noted <span class="math inline">\(Set_{n}\)</span>, where <span class="math inline">\(n \in \mathbb{N}\)</span> is the <em>level</em> of that universe. You can introduce them with the <code>universe</code> builtin, that takes in a level and pushes a universe of that level on the stack :</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="0">0</span> <span class="symbol" data-symbol-name="universe">universe</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>We just proved something ! Granted, we only proved that some universes exist, by giving an example of one, but still. Using that universe as a starting point, we can explore a bit further.</p>
<p>The first useful thing we can do given a term is ask CaPriCon to give us its type, unsurprisingly by using the <code>type</code> builtin.</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="dup">dup</span> <span class="symbol" data-symbol-name="type">type</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>We can see that <span class="math inline">\(Set_{0}\)</span> has type <span class="math inline">\(Set_{1}\)</span>. In general, when a term has type <span class="math inline">\(Set_{n}\)</span> for some <span class="math inline">\(n\)</span>, we can treat that term as a <em>type</em>, that may or may not contain <em>objects</em>. Every well-formed term has a type, that can be computed with <code>type</code> as we observed, but not every well-formed term <em>is</em> a type.</p>
<h2 id="the-proof-context">The proof context</h2>
<p>Many mathematical proofs begin by assuming the existence of a few objects, before studying those objects in more detail (“let n, m be two natural numbers, …”, “let f be a function from A to B, …”). Once those objects are <em>introduced</em> to the reader, the rest of the proof can refer to them as though they already had a proper value of the given type.</p>
<h3 id="introducing-new-hypotheses">Introducing new hypotheses</h3>
<p>CaPriCon works in a similar way. If we have a type on top of the stack, like we do now, we can <code>intro</code>duce a variable (or hypothesis) of that type. Introducing a new hypothesis from a type is equivalent to assuming that at least one term of that type exists, without caring about that term’s specific shape.</p>
<p>If our type is a universe, like <span class="math inline">\(Set_{0}\)</span>, we’ll call such a hypothesis a <em>property</em> of its type, as a convention. Otherwise, we’ll usually call it a <em>witness</em> of some property.</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="pop">pop</span> <span class="symbol" data-symbol-name="'Prop">'Prop</span> <span class="symbol" data-symbol-name="intro">intro</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<h3 id="using-hypotheses">Using hypotheses</h3>
<p>We now have a fresh but unknown property of <span class="math inline">\(Set_{0}\)</span>, called <code>Prop</code>, in the context. We can retrieve that property by using its name, using the <code>variable</code> builtin, and check that it is indeed an element of the universe <span class="math inline">\(Set_{0}\)</span>.</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="'Prop">'Prop</span> <span class="symbol" data-symbol-name="variable">variable</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
<button class="capricon-example" data-code="dup type vis">
<pre class="capricon"><span class="symbol" data-symbol-name="dup">dup</span> <span class="symbol" data-symbol-name="type">type</span> <span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>We can go further, though. Our property <code>Prop</code> is still a type (because it has a type of shape <span class="math inline">\(Set_{n}\)</span>, remember ?), so we can introduce a witness of it if we want. Let’s call that witness <code>p</code> :</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="'p">'p</span> <span class="symbol" data-symbol-name="intro">intro</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
<button class="capricon-example" data-code="&#39;p variable type vis">
<pre class="capricon"><span class="symbol" data-symbol-name="'p">'p</span> <span class="symbol" data-symbol-name="variable">variable</span> <span class="symbol" data-symbol-name="type">type</span> <span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<h3 id="clearing-hypotheses">Clearing hypotheses</h3>
<p>Once a variable has been introduced, and used to construct some terms, it can be <em>extroduced</em> from the context, which has the effect of closing those terms under binders. The builtin verbs <code>extro-lambda</code> and <code>extro-forall</code> have the function of extroducing the last hypothesis that was introduced, respectively using lambda abstractions and products (“forall”).</p>
<p>In our running example, we can for example create the term <label class="expansible inline"><span><span class="math inline">\(λ(\mathrm{p}:\mathrm{Prop}).\,\mathrm{p}\)</span> </span><input type="checkbox"><span class="expand-then"><code class="capricon capricon-steps"><span class="symbol" data-symbol-name="&#39;p">’p</span> <span class="symbol" data-symbol-name="variable">variable</span> <span class="symbol" data-symbol-name="lambda">lambda</span> <span class="symbol" data-symbol-name="tex">tex</span></code></span></label> by extroducing a lambda abstraction after creating the term <label class="expansible inline"><span><span class="math inline">\(\mathrm{p}\)</span> </span><input type="checkbox"><span class="expand-then"><code class="capricon capricon-steps"><span class="symbol" data-symbol-name="&#39;p">’p</span> <span class="symbol" data-symbol-name="variable">variable</span> <span class="symbol" data-symbol-name="tex">tex</span></code></span></label>.</p>
<label class="expansible box"><input type="checkbox" checked="checked" /><span class="expand-else capricon-show"></span><span class="expand-then capricon-hide"></span><span class="expand-then" style="--num-lines: 4.25">
<div class="capricon-steps">
<pre class="capricon capricon-paragraph capricon-context"><span class="symbol" data-symbol-name="'p">'p</span> <span class="symbol" data-symbol-name="variable">variable</span> <span class="symbol" data-symbol-name="'Prop">'Prop</span> <span class="symbol" data-symbol-name="variable">variable</span> <span class="symbol" data-symbol-name="extro-lambda">extro-lambda</span></pre>
<div class="capricon-examples">
<button class="capricon-example" data-code="vis">
<pre class="capricon"><span class="symbol" data-symbol-name="vis">vis</span></pre>
</button>
</div>
<div class="user-input interactive">
<button class="capricon-trigger">
Try It Out
</button>
<label class="capricon-input-prefix">&gt; <input type="text" class="capricon-input" /></label>
<pre class="capricon-output"></pre>
</div>
</div>
</span></label>
<div class="capricon-paragraphresult">

</div>
<p>Notice how the <code>p</code> hypothesis disappeared from the context, only to be found “transferred” to the terms on the stack that reference it. The <code>Prop</code> hypothesis was not affected because it couldn’t possibly refer to <code>p</code>, being defined before it.</p>
<p><br/></p>
<p>That’s about all there is to hypotheses : use <code>intro</code> to create new ones; create some terms using <code>variable</code> et al.; and finally, clear them from the environment using some kind of extroduction.</p>
<h2 id="functions-products-and-applications">Functions, Products and Applications</h2>
<div class="in-progress">

</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>For now, 32-bit integers are the default, but if the need arises, I’ll be glad to throw in some BigInt or floating-point support<a href="#fnref1" class="footnote-back" role="doc-backlink">↩</a></p></li>
</ol>
</section>
<footer>Page generated on Wednesday, May 01 of 2019, at 14:21 PM UTC, using capricon-0.13.1.2 and pandoc-2.7.2.</footer>
    </article></div></main>
<script id="capricon-prelude" type="text/plain">'nop { { } } def 'get { nop nop lookup } def  'each list 1 dupn get def 'dict-keys dict 'keys get def 'import-keys {   { 1 dupn 1 dupn get def } each   pop } def  'import {   dup dict-keys import-keys  } def  [ dict term-index construction query context io list arith string ] { import } each  'printf { format print pop } def 'show { "%v\n" printf } def 'show-stack { stack { show } each } def 'times { range { pop dup exec } each pop } def 'reverse { [ ] swap { cons } each } def  'eol. { } def 'mustache. { show } def 'tex { 'mustache. { "$%l$\n" printf 'mustache. ,{ dup $ } def } def } def 'svg { 'mustache. { "<svg class='capricon-formula' width='150px' height='2em' viewBox='0 0 100 100' xmlns=\"http://www.w3.org/2000/svg\"><text class='formula-text' x='0' y='100'>%g</text></svg>" printf 'mustache. ,{ dup $ } def } def } def 'raw { 'mustache. { "%s\n" printf 'mustache. ,{ dup $ } def } def } def 'newline { } def  'collect { { 'exports empty def ${ } exports { ,{ ,{ vocabulary } } set-vocabulary ,{ ,{ stack } } set-stack ,{ exports } } exec } exec } def 'exports empty def 'export { exports swap dup $ insert 'exports swap def } def  [ 'source-dir 'output-dir 'cache-dir ] { "" def } each  'module { source-dir "%s%s" format source exec } def 'require { dup dup "  * Required module: [%s][:%s]\n" printf { ,{ dup } { module } collect } swap cache-dir "%s%s.mdo" format cache } def   </script>
<div id="capricon-console"></div>
<script type="text/javascript">
  window.addEventListener("load",function() {
      var formulae = document.getElementsByClassName('capricon-formula');
      for(var i = 0; i < formulae.length; i++) {
	  var formula = formulae.item(i);
	  var box = formula.getBBox();
	  var w = Math.ceil(box.width)*1.05; h = Math.ceil(box.height)*1.05;
	  var x = Math.floor(box.x), y = Math.floor(box.y);
	  
	  formula.setAttribute("viewBox", x+" "+y+" "+w+" "+h);
	  formula.setAttribute("width", w);
	  formula.setAttribute("height", h);
      }
  });
</script>
<div id="body-theme-chooser" style="z-index: 100; position: fixed; text-align: right; left: 0; bottom: 0; font-size: 1rem !important" class="opaque frame level-12">
  <div class="sheet">
    <script>
      document.addEventListener('DOMContentLoaded',function() {
	  Theme.attach(document.getElementsByTagName('body')[0]);
      });
    </script>
    <label>Ambiance: <select class="theme-ambiance-select">
	<option value="day" selected="selected">Day</option>
	<option value="night">Night</option>
      </select>
    </label>
    <style>.theme-prop-display { min-width: 4em; display: inline-block; }</style>
    <label class="theme-slider" style="display: block">Primary hue<input type="range" min="0" max="360" value="180"/><span class="theme-prop-display" data-prop-name="--prim-hue"></span></label>	
    <label class="theme-slider" style="display: block">Primary saturation<input type="range" min="0" max="100" value="50" /><span class="theme-prop-display" data-prop-name="--prim-saturation"></span></label>
    <label class="theme-slider" style="display: block">Low hue<input type="range" min="-180" max="180" value="0"/><span class="theme-prop-display" data-prop-name="--low-hue"></span></label>	
    <label class="theme-slider" style="display: block">Low saturation<input type="range" min="0" max="100" value="50"/><span class="theme-prop-display" data-prop-name="--low-saturation"></span></label>
    <label class="theme-slider" style="display: block">High hue<input type="range" min="-180" max="180" value="0"/><span class="theme-prop-display" data-prop-name="--high-hue"></span></label>	
    <label class="theme-slider" style="display: block">High saturation<input type="range" min="0" max="100" value="50"/><span class="theme-prop-display" data-prop-name="--high-saturation"></span></label>
    <label class="theme-slider" style="display: block">Min contrast<input type="range" min="10" max="100" value="50" /><span class="theme-prop-display" data-prop-name="--min-contrast"></span></label>
    <label class="theme-slider" style="display: block">Max contrast<input type="range" min="10" max="100" value="0" /><span class="theme-prop-display" data-prop-name="--max-contrast"></span></label>
    <label class="theme-slider" style="display: block">Luminosity<input type="range" min="0" max="100" value="180"/><span class="theme-prop-display" data-prop-name="--luminosity"></span></label>
    <button onclick="document.getElementById('body-theme-chooser').classList.toggle('active'); document.body.classList.toggle('smooth-colors');">Close</button>
  </div>
</div>
</body>
</html>
