<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marc Coiffier" />
  <title>Reflections on Prismatic Constructions</title>
  <style type="text/css">
    code{white-space: pre;}
    #capricon-prelude { display: none; }
    .capricon-output { display: inline-block; }
    .capricon-hide + .capricon-hidestache::before {
	content: "";
	width: 0.5em; height: 0.5em; display: inline-block;
	position: relative; bottom: 0.3em;
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAgCAQAAABNlRuNAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QA/4ePzL8AAAAJcEhZcwAALiMAAC4jAXilP3YAAAAHdElNRQfiCR0AADLw7KyaAAAB3UlEQVQ4y43UPUhVYRzH8c99scTMLAkkySx0MNOipfeW2iqa2xrEGgIpjQY3l4YwIxJ6gbaWpIZAC1oaggoiJKgsjODSGxJBwaUyb09Dp8O9ei6c3/Q8P/j+n//bORnptUm/4Gw+NdDpsl1KPqYF6twQBMHtbEpkr0PRqZivEnOfRhO+RveMw5aDec+SgHojiuYNxk7egBl/BG/1JCH95v5lbUmZ2+6UR4blFgPtpv8XGiNtOmXRpCHpjRMREJyLnJwxBVfsVqVZQ74LgqKDkdMavTuuNhmpt981H0xqjJz1ZgQlfdVG1oisHp2xl3PMQ6OakpFeD5y0YYGb0aCmWlL3BMFdq1RVZQ/qrAHvfJNSeUM+eWxr7DRoSRpeuWp1aYlv20166UjaF+kyFVVWlw5Y6nq0BU+sTC6/RlNF1lvi6X/xMwlpdcF9x8tC7LA6Oj31Y3ESTW4Jgueayyo5741g1rakvAeUBEFBR4XfbtBAxVcTqSXqTPAiGiUb9euWJXnhD/gVITfjiMOCgtG4ngXlTxszI5h3xxxYZifW2iNTfQodTrsYr3eNq4LfZT+MCjU7qluGivVe54w+K5KRXkUFl7RJrXFB8NnmtEDWeyVMeJUWyXmtZMqI2bTIX4FHiXN3BEaSAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE4LTA5LTI4VDIzOjM0OjE0KzAyOjAw5BdphAAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOC0wOS0yOFQyMjowMDo1MCswMjowMKjQ5C8AAAAASUVORK5CYII=);
	background-size: 100% 100%;
	background-repeat: none;
	padding: 0.2em;
	border: 1px solid rgba(255,255,255,0);
    }
  </style>
  <noscript>
    <style>.interactive { display: none !important; }</style>
  </noscript>
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <link rel="icon" type="image/png" href="favicon.png" />
  <!-- <script src="WiQEE.js"></script> -->
  <script defer src="WiQEE.js"></script>
  <script src="theme-tweak.js"></script>
</head>
<body class="ground-light primary" style="font-size: 100%;">
<main id="content-frame" class="frame"><header class="nav header reverse">
    <span class="menu left"><a href="index.html">WiQEE</a><ul>
  	<li><a href="#">Documentation</a><ul>
	    <li><a href="lexicon.html">Lexicon</a></li>
  	    <li><a href="capricon-tutorial.html">Tutorial</a></li>
	</ul></li>
	<li><a class="interactive" href="#" onclick="document.getElementById('body-theme-chooser').classList.toggle('active'); document.body.classList.toggle('smooth-colors');">Tweak theme</a></li>
    </ul></span><span class="menu middle"><a class="#">Reflections on Prismatic Constructions</a>
            <ul>
      <li><a href="#the-pure-calculus-of-construction">The pure Calculus of Construction</a></li>
      <li><a href="#the-limits-of-constructions">The Limits of Constructions</a><ul>
      <li><a href="#intuitionistic-booleans">Intuitionistic Booleans</a></li>
      <li><a href="#sameness-aka.-identity">Sameness (aka. Identity)</a></li>
      <li><a href="#putting-it-all-together">Putting it all together</a></li>
      </ul></li>
      <li><a href="#inductive-types">Inductive Types</a></li>
      <li><a href="#the-mu-combinator-lambda-constructions-with-extra-steps">The <span class="math inline">\(\mu\)</span> Combinator : Lambda-constructions with extra steps</a></li>
      </ul>
          </span><span class="menu right"><a href="mu-combinator.md">Page source</a><ul>
	<li><a href="https://github.com/lih/WiQEE-pages/edit/master/mu-combinator.md">Edit</a></li>
	<li><a href="mu-combinator.pdf">PDF version</a></li>
      </ul></span>
  </header><div id="content-scroll"><article id="content" class="sheet" tabindex="1">
<h1>Reflections on Prismatic Constructions</h1>
<p>The Calculus of Prismatic Constructions, upon which this platform is based, is an extension of the standard <a href="https://en.wikipedia.org/wiki/Calculus_of_constructions">CoC</a> with a mechanism for discriminating inductive constructors.</p>
<h2 id="the-pure-calculus-of-construction">The pure Calculus of Construction</h2>
<p>It is already very well-described elsewhere, so I won’t try to provide a full and correct history of the CoC. Suffice to say that it is a logically consistent programming language, that can prove properties within the framework of intuitionistic logic.</p>
<p>At its simplest, it provides five basic constructions :</p>
<ul>
<li><p>universes, of the form <span class="math inline">\(Set_n\)</span>, are the “types of types”. <span class="math inline">\(Set_{n+1}\)</span> is the type of <span class="math inline">\(Set_{n}\)</span></p></li>
<li><p>products, noted <span class="math inline">\(\forall (x:X), Y\,x\)</span> – or <span class="math inline">\(X\ \rightarrow\ Y\)</span> when <span class="math inline">\(Y\)</span> doesn’t depend on x – are the “types of functions”. <span class="math inline">\(\mathbb{N}\ \rightarrow\ \mathbb{R}\)</span>, for instance is the type of functions from the natural numbers to the real numbers.</p></li>
<li><p>functions or lambdas, noted <span class="math inline">\(\lambda (x:X), Y\,x\)</span>, are the “proofs of products”. A valid lambda can be interpreted as the proof of a property, quantified over its variable.</p></li>
<li><p>hypotheses, or variables, are the symbols introduced by surrounding quantifiers (<span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\forall\)</span>). In their context, they are valid proofs of their type.</p>
<p>For example, the identity function can be written <span class="math inline">\(\lambda (A:Set_{0}), \lambda (a:A), a\)</span>, and it is a valid proof of <span class="math inline">\(\forall (A:Set_{0}), \forall (a:A), A\)</span>, since <span class="math inline">\(a\)</span> is a valid proof of <span class="math inline">\(A\)</span> in its context.</p></li>
<li><p>Applications, of the form <span class="math inline">\(f\,x\)</span>, where <span class="math inline">\(f : \forall (x:X), Y\,x\)</span> and <span class="math inline">\(x : X\)</span>, signify the specialization of a quantified property over an object <span class="math inline">\(x\)</span>.</p>
<p>For instance, given a proof <span class="math inline">\(f\)</span> of <span class="math inline">\(\forall (x:\mathbb{N}), \exists (y:\mathbb{N}), y = x+1\)</span>, we can prove that <span class="math inline">\(\exists (y:\mathbb{N}), y=10+1\)</span>, by applying <span class="math inline">\(f\)</span> to <span class="math inline">\(10\)</span> (aka. <span class="math inline">\(f\,10\)</span>).</p></li>
</ul>
<p>Given these axioms, we can build many theorems and their proofs, in a verifiable manner (i.e. there exists an algorithm to automatically check whether a claim like <span class="math inline">\(x : X\)</span> holds).</p>
<p>However, it’s been known for a while that the CoC by itself is not capable of handling a large class of the proofs that modern mathematicians (and even ancient ones) take for granted.</p>
<h2 id="the-limits-of-constructions">The Limits of Constructions</h2>
<p>To illustrate the kind of reasoning that can’t be carried out with raw intuitionistic logic, let’s take an obvious statement : a boolean is either equal to true or to false.</p>
<p>We’d like to prove this statement using only the tools given by the CoC. For this, we have to define a few concepts, namely our Booleans, <span class="math inline">\(true\)</span> and <span class="math inline">\(false\)</span>, and what it means for two things to be equal.</p>
<h3 id="intuitionistic-booleans">Intuitionistic Booleans</h3>
<p>In order for two things to be considered the same, they must at least belong to the same family. In this case, it means that <span class="math inline">\(true\)</span> and <span class="math inline">\(false\)</span> must have the same type. By convention, we’ll call the type of “true or false” the <span class="math inline">\(Boolean\)</span> type, in honor of George Boole.</p>
<p>Given a Boolean <span class="math inline">\(b\)</span>, we would like to be able to return different values from a function, depending on whether <span class="math inline">\(b\)</span> is true or false. Otherwise, our Boolean wouldn’t be much use in a computation.</p>
<p>With all that in mind, here is the definition I propose the <span class="math inline">\(Boolean\)</span> type :</p>
<p><span class="math display">\[
Boolean \equiv \forall (P:Prop) (ptrue:P) (pfalse:P), P
\]</span></p>
<p>That is, a Boolean is a way to produce any <span class="math inline">\(P\)</span>, given two alternatives <span class="math inline">\(ptrue\)</span> and <span class="math inline">\(pfalse\)</span>, and nothing else.</p>
<p>There are, intuitively, only two distinct ways to construct a closed Boolean term, given the above definition :</p>
<ul>
<li><span class="math inline">\(true \equiv \lambda (P:Prop) (ptrue:P) (pfalse:P). ptrue\)</span></li>
<li><span class="math inline">\(false \equiv \lambda (P:Prop) (ptrue:P) (pfalse:P). pfalse\)</span></li>
</ul>
<p>Our goal in the following sections will be to try and confirm this intuition, by proving it in the CoC.</p>
<h3 id="sameness-aka.-identity">Sameness (aka. Identity)</h3>
<p>Two values <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> can be said to be the same (when it comes to proving theorems) if everything that can be proven of <span class="math inline">\(x\)</span> can also be proven of <span class="math inline">\(y\)</span>. More formally, given a type <span class="math inline">\(A\)</span> of things, and two values <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> of type <span class="math inline">\(A\)</span> we have :</p>
<p><span class="math display">\[
(x\ =\ y) \equiv \forall (P:A\ \rightarrow\ Set_{n}), P\,x\ \rightarrow\ P\,y
\]</span></p>
<p>We can easily prove some intuitive properties for the <span class="math inline">\(=\)</span> relation, such as :</p>
<ul>
<li><p>reflexivity : <span class="math inline">\((x\ =\ x)\)</span>, as proven by <span class="math inline">\(\lambda (P:A\ \rightarrow\ Set_{n}) (p:P x). p\)</span></p></li>
<li><p>symmetry : <span class="math inline">\((x\ =\ y) \rightarrow (y\ =\ x)\)</span>, proven by <span class="math inline">\(\lambda (e:x\ =\ y) (P:A\ \rightarrow\ Set_{n}) (py:P y), e \,(\lambda (a:A). P\,a \rightarrow P\,x)\,(\lambda (px:P\,x). px)\,py\)</span></p></li>
<li><p>transitivity : <span class="math inline">\((x\ =\ y)\ \rightarrow\ (y\ =\ z)\
\rightarrow\ (x\ =\ z)\)</span>, as proven by <span class="math inline">\(\lambda (e_1:x\ =\
y) (e_2:y\ =\ z) (P:A\ \rightarrow\ Set_{n}) (px:P x). e_2\,P\, (e_1\,P\,px)\)</span></p></li>
</ul>
<h3 id="putting-it-all-together">Putting it all together</h3>
<p>We now have everything we need to prove that every Boolean is either <span class="math inline">\(true\)</span> or <span class="math inline">\(false\)</span>. First, let’s formally state that property :</p>
<p><span class="math display">\[
\forall (b:Boolean), (b\ =\ true) \cup (b\ =\ false) \\
\equiv \forall (b:Boolean) (P:Set_{n}), (b\ =\ true\ \rightarrow\ P)\ \rightarrow\ (b\ =\ false\ \rightarrow\ P)\ \rightarrow\ P
\]</span></p>
<h2 id="inductive-types">Inductive Types</h2>
<p>Inductive types can be described as enumerations of constructors. In Coq (and similarly in other proof assistants), an inductive type must be declared along with its constructors, using a syntax like :</p>
<pre class="coq"><code>Inductive T : forall A..., Type :=
| t0 : forall x0..., T (f0... x0...) 
...
| tn : forall xn..., T (fn... xn...)
.</code></pre>
<p>Here, we declare the inductive type <span class="math inline">\(T : \forall A..., Type\)</span>, and its constructors called <span class="math inline">\(t_{i}\)</span> (<span class="math inline">\(i \in \{0..n\}\)</span>).</p>
<p>As a more concrete example, here is how the type of Booleans can be defined inductively :</p>
<pre class="coq"><code>Inductive Boolean : Type := true : Boolean | false : Boolean.</code></pre>
<p>The above definition is essentially a formal statement of the following description of Booleans : a Boolean can have one of two shapes, <span class="math inline">\(true\)</span> or <span class="math inline">\(false\)</span>, and cannot be any other thing.</p>
<p>This means that, if we want to prove a property <span class="math inline">\(P\,x\)</span> for some unknown Boolean <span class="math inline">\(x\)</span>, all we need is to prove <span class="math inline">\(P\,true\)</span> and <span class="math inline">\(P\,false\)</span>.</p>
<p>This exact information is summed up in what we call the <em>induction principle</em> for Booleans. In Coq, it will be given the name <code>Boolean_rect</code>, for instance, and have the type <span class="math inline">\(\forall (P:Boolean\,\rightarrow\,Type),\ P\,true\ \rightarrow\ P\,false\
\rightarrow\ \forall (b:Boolean),\ P\,b\)</span>.</p>
<h2 id="the-mu-combinator-lambda-constructions-with-extra-steps">The <span class="math inline">\(\mu\)</span> Combinator : Lambda-constructions with extra steps</h2>
<p><span class="math display">\[
\mu(x) \equiv \mu_{\varnothing}(x)
\]</span></p>
<p><span class="math display">\[
\mu_{\Gamma}(\lambda(x:T). y)
\equiv
\mu_{\Gamma, (x:T)}(y)
\]</span></p>
<p><span class="math display">\[
\mu_{\Gamma}(H x...) \equiv \lambda^* \Gamma^\uparrow. \Gamma^\uparrow[H x]...
\]</span></p>
<p><span class="math display">\[
\varnothing^\uparrow \equiv \varnothing \\
(\Gamma, (x:T_{\Gamma}))^\uparrow \equiv \Gamma^\uparrow, (x:T_{\Gamma^\uparrow})
\]</span></p>
<footer>Page generated on Tuesday, September 24 of 2019, at 15:37 PM UTC, using capricon-0.13.1.2 and pandoc-2.7.2.</footer>
    </article></div></main>
<script id="capricon-prelude" type="text/plain">'nop { { } } def 'get { nop nop lookup } def  'each list 1 dupn get def 'dict-keys dict 'keys get def 'import-keys {   { 1 dupn 1 dupn get def } each   pop } def  'import {   dup dict-keys import-keys  } def  [ dict term-index construction query context io list arith string ] { import } each  'printf { format print pop } def 'show { "%v\n" printf } def 'show-stack { stack { show } each } def 'times { range { pop dup exec } each pop } def 'reverse { [ ] swap { cons } each } def  'eol. { } def 'mustache. { show } def 'tex { 'mustache. { "$%l$\n" printf 'mustache. ,{ dup $ } def } def } def 'svg { 'mustache. { "<svg class='capricon-formula' width='150px' height='2em' viewBox='0 0 100 100' xmlns=\"http://www.w3.org/2000/svg\"><text class='formula-text' x='0' y='100'>%g</text></svg>" printf 'mustache. ,{ dup $ } def } def } def 'raw { 'mustache. { "%s\n" printf 'mustache. ,{ dup $ } def } def } def 'newline { } def  'collect { { 'exports empty def ${ } exports { ,{ ,{ vocabulary } } set-vocabulary ,{ ,{ stack } } set-stack ,{ exports } } exec } exec } def 'exports empty def 'export { exports swap dup $ insert 'exports swap def } def  [ 'source-dir 'output-dir 'cache-dir ] { "" def } each  'module { source-dir "%s%s" format source exec } def 'require { dup dup "  * Required module: [%s][:%s]\n" printf { ,{ dup } { module } collect } swap cache-dir "%s%s.mdo" format cache } def   </script>
<div id="capricon-console"></div>
<script type="text/javascript">
  window.addEventListener("load",function() {
      var formulae = document.getElementsByClassName('capricon-formula');
      for(var i = 0; i < formulae.length; i++) {
	  var formula = formulae.item(i);
	  var box = formula.getBBox();
	  var w = Math.ceil(box.width)*1.05; h = Math.ceil(box.height)*1.05;
	  var x = Math.floor(box.x), y = Math.floor(box.y);
	  
	  formula.setAttribute("viewBox", x+" "+y+" "+w+" "+h);
	  formula.setAttribute("width", w);
	  formula.setAttribute("height", h);
      }
  });
</script>
<div id="body-theme-chooser" style="z-index: 100; position: fixed; text-align: right; left: 0; bottom: 0; font-size: 1rem !important" class="opaque frame level-12">
  <div class="sheet">
    <script>
      document.addEventListener('DOMContentLoaded',function() {
	  Theme.attach(document.getElementsByTagName('body')[0]);
      });
    </script>
    <label>Ambiance: <select class="theme-ambiance-select">
	<option value="day" selected="selected">Day</option>
	<option value="night">Night</option>
      </select>
    </label>
    <style>.theme-prop-display { min-width: 4em; display: inline-block; }</style>
    <label class="theme-slider" style="display: block">Primary hue<input type="range" min="0" max="360" value="180"/><span class="theme-prop-display" data-prop-name="--prim-hue"></span></label>	
    <label class="theme-slider" style="display: block">Primary saturation<input type="range" min="0" max="100" value="50" /><span class="theme-prop-display" data-prop-name="--prim-saturation"></span></label>
    <label class="theme-slider" style="display: block">Low hue<input type="range" min="-180" max="180" value="0"/><span class="theme-prop-display" data-prop-name="--low-hue"></span></label>	
    <label class="theme-slider" style="display: block">Low saturation<input type="range" min="0" max="100" value="50"/><span class="theme-prop-display" data-prop-name="--low-saturation"></span></label>
    <label class="theme-slider" style="display: block">High hue<input type="range" min="-180" max="180" value="0"/><span class="theme-prop-display" data-prop-name="--high-hue"></span></label>	
    <label class="theme-slider" style="display: block">High saturation<input type="range" min="0" max="100" value="50"/><span class="theme-prop-display" data-prop-name="--high-saturation"></span></label>
    <label class="theme-slider" style="display: block">Min contrast<input type="range" min="10" max="100" value="50" /><span class="theme-prop-display" data-prop-name="--min-contrast"></span></label>
    <label class="theme-slider" style="display: block">Max contrast<input type="range" min="10" max="100" value="0" /><span class="theme-prop-display" data-prop-name="--max-contrast"></span></label>
    <label class="theme-slider" style="display: block">Luminosity<input type="range" min="0" max="100" value="180"/><span class="theme-prop-display" data-prop-name="--luminosity"></span></label>
    <button onclick="document.getElementById('body-theme-chooser').classList.toggle('active'); document.body.classList.toggle('smooth-colors');">Close</button>
  </div>
</div>
</body>
</html>
